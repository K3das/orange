// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createStartedTranscription = `-- name: CreateStartedTranscription :exec
INSERT INTO asr_transcriptions (
    guild_id,
    channel_id,
    original_message_id,
    original_message_deleted,
    original_message_timestamp,
    response_message_id,
    transcription_status
) VALUES ($1, $2, $3, $4, $5, $6, 'started')
`

type CreateStartedTranscriptionParams struct {
	GuildID                  string
	ChannelID                string
	OriginalMessageID        string
	OriginalMessageDeleted   bool
	OriginalMessageTimestamp pgtype.Timestamptz
	ResponseMessageID        string
}

func (q *Queries) CreateStartedTranscription(ctx context.Context, arg CreateStartedTranscriptionParams) error {
	_, err := q.db.Exec(ctx, createStartedTranscription,
		arg.GuildID,
		arg.ChannelID,
		arg.OriginalMessageID,
		arg.OriginalMessageDeleted,
		arg.OriginalMessageTimestamp,
		arg.ResponseMessageID,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id)
VALUES ($1)
ON CONFLICT (id) DO NOTHING
`

func (q *Queries) CreateUser(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, createUser, id)
	return err
}

const getTranscriptionByOriginalMessage = `-- name: GetTranscriptionByOriginalMessage :one
SELECT guild_id, channel_id, original_message_id, original_message_deleted, original_message_timestamp, response_message_id, response_deleted, transcription_status, voice_message_audio_duration, transcription_model, transcription_processing_time FROM asr_transcriptions
WHERE 
    guild_id=$1 AND
    channel_id=$2 AND
    original_message_id=$3
LIMIT 1
`

type GetTranscriptionByOriginalMessageParams struct {
	GuildID           string
	ChannelID         string
	OriginalMessageID string
}

func (q *Queries) GetTranscriptionByOriginalMessage(ctx context.Context, arg GetTranscriptionByOriginalMessageParams) (AsrTranscription, error) {
	row := q.db.QueryRow(ctx, getTranscriptionByOriginalMessage, arg.GuildID, arg.ChannelID, arg.OriginalMessageID)
	var i AsrTranscription
	err := row.Scan(
		&i.GuildID,
		&i.ChannelID,
		&i.OriginalMessageID,
		&i.OriginalMessageDeleted,
		&i.OriginalMessageTimestamp,
		&i.ResponseMessageID,
		&i.ResponseDeleted,
		&i.TranscriptionStatus,
		&i.VoiceMessageAudioDuration,
		&i.TranscriptionModel,
		&i.TranscriptionProcessingTime,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :one
SELECT id, asr_enabled, asr_enabled_touched_at, asr_nudged, asr_nudged_touched_at FROM users
WHERE id=$1 LIMIT 1
`

func (q *Queries) GetUsers(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, getUsers, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.AsrEnabled,
		&i.AsrEnabledTouchedAt,
		&i.AsrNudged,
		&i.AsrNudgedTouchedAt,
	)
	return i, err
}

const updateTranscriptionDone = `-- name: UpdateTranscriptionDone :one
UPDATE asr_transcriptions
SET 
    transcription_status='done',
    voice_message_audio_duration=$4,
    transcription_model=$5,
    transcription_processing_time=$6
WHERE 
    guild_id=$1 AND
    channel_id=$2 AND
    original_message_id=$3
RETURNING guild_id, channel_id, original_message_id, original_message_deleted, original_message_timestamp, response_message_id, response_deleted, transcription_status, voice_message_audio_duration, transcription_model, transcription_processing_time
`

type UpdateTranscriptionDoneParams struct {
	GuildID                     string
	ChannelID                   string
	OriginalMessageID           string
	VoiceMessageAudioDuration   pgtype.Float8
	TranscriptionModel          pgtype.Text
	TranscriptionProcessingTime pgtype.Float8
}

func (q *Queries) UpdateTranscriptionDone(ctx context.Context, arg UpdateTranscriptionDoneParams) (AsrTranscription, error) {
	row := q.db.QueryRow(ctx, updateTranscriptionDone,
		arg.GuildID,
		arg.ChannelID,
		arg.OriginalMessageID,
		arg.VoiceMessageAudioDuration,
		arg.TranscriptionModel,
		arg.TranscriptionProcessingTime,
	)
	var i AsrTranscription
	err := row.Scan(
		&i.GuildID,
		&i.ChannelID,
		&i.OriginalMessageID,
		&i.OriginalMessageDeleted,
		&i.OriginalMessageTimestamp,
		&i.ResponseMessageID,
		&i.ResponseDeleted,
		&i.TranscriptionStatus,
		&i.VoiceMessageAudioDuration,
		&i.TranscriptionModel,
		&i.TranscriptionProcessingTime,
	)
	return i, err
}

const updateTranscriptionFailed = `-- name: UpdateTranscriptionFailed :one
UPDATE asr_transcriptions
SET 
    transcription_status='failed'
WHERE 
    guild_id=$1 AND
    channel_id=$2 AND
    original_message_id=$3
RETURNING guild_id, channel_id, original_message_id, original_message_deleted, original_message_timestamp, response_message_id, response_deleted, transcription_status, voice_message_audio_duration, transcription_model, transcription_processing_time
`

type UpdateTranscriptionFailedParams struct {
	GuildID           string
	ChannelID         string
	OriginalMessageID string
}

func (q *Queries) UpdateTranscriptionFailed(ctx context.Context, arg UpdateTranscriptionFailedParams) (AsrTranscription, error) {
	row := q.db.QueryRow(ctx, updateTranscriptionFailed, arg.GuildID, arg.ChannelID, arg.OriginalMessageID)
	var i AsrTranscription
	err := row.Scan(
		&i.GuildID,
		&i.ChannelID,
		&i.OriginalMessageID,
		&i.OriginalMessageDeleted,
		&i.OriginalMessageTimestamp,
		&i.ResponseMessageID,
		&i.ResponseDeleted,
		&i.TranscriptionStatus,
		&i.VoiceMessageAudioDuration,
		&i.TranscriptionModel,
		&i.TranscriptionProcessingTime,
	)
	return i, err
}

const updateTranscriptionMessageDeleted = `-- name: UpdateTranscriptionMessageDeleted :one
UPDATE asr_transcriptions
SET 
    response_deleted=
        CASE WHEN response_message_id=$3::text THEN TRUE ELSE response_deleted END,

    original_message_deleted=
        CASE WHEN original_message_id=$3::text THEN TRUE ELSE original_message_deleted END
WHERE 
    guild_id=$1 AND
    channel_id=$2 AND
    (
        original_message_id=$3::text OR 
        response_message_id=$3::text
    )
RETURNING guild_id, channel_id, original_message_id, original_message_deleted, original_message_timestamp, response_message_id, response_deleted, transcription_status, voice_message_audio_duration, transcription_model, transcription_processing_time
`

type UpdateTranscriptionMessageDeletedParams struct {
	GuildID   string
	ChannelID string
	MessageID string
}

func (q *Queries) UpdateTranscriptionMessageDeleted(ctx context.Context, arg UpdateTranscriptionMessageDeletedParams) (AsrTranscription, error) {
	row := q.db.QueryRow(ctx, updateTranscriptionMessageDeleted, arg.GuildID, arg.ChannelID, arg.MessageID)
	var i AsrTranscription
	err := row.Scan(
		&i.GuildID,
		&i.ChannelID,
		&i.OriginalMessageID,
		&i.OriginalMessageDeleted,
		&i.OriginalMessageTimestamp,
		&i.ResponseMessageID,
		&i.ResponseDeleted,
		&i.TranscriptionStatus,
		&i.VoiceMessageAudioDuration,
		&i.TranscriptionModel,
		&i.TranscriptionProcessingTime,
	)
	return i, err
}

const updateUserASREnabled = `-- name: UpdateUserASREnabled :exec
UPDATE users
SET asr_enabled=$1, asr_enabled_touched_at=NOW()
WHERE id=$2
`

type UpdateUserASREnabledParams struct {
	AsrEnabled bool
	ID         string
}

func (q *Queries) UpdateUserASREnabled(ctx context.Context, arg UpdateUserASREnabledParams) error {
	_, err := q.db.Exec(ctx, updateUserASREnabled, arg.AsrEnabled, arg.ID)
	return err
}

const updateUserASRNudge = `-- name: UpdateUserASRNudge :exec
UPDATE users
SET asr_nudged=$1, asr_nudged_touched_at=NOW()
WHERE id=$2
`

type UpdateUserASRNudgeParams struct {
	AsrNudged bool
	ID        string
}

func (q *Queries) UpdateUserASRNudge(ctx context.Context, arg UpdateUserASRNudgeParams) error {
	_, err := q.db.Exec(ctx, updateUserASRNudge, arg.AsrNudged, arg.ID)
	return err
}
